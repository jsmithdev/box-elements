{"version":3,"sources":["webpack:///./node_modules/filesize/lib/filesize.js","webpack:///./node_modules/ilib-tree-node/TreeNode-es5.js","webpack:///./node_modules/lodash/isFinite.js","webpack:///./node_modules/lodash/isNil.js","webpack:///./node_modules/message-accumulator/message-accumulator-es5.js","webpack:///./node_modules/react-process-string/dist/index.js","webpack:///./node_modules/tabbable/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,8CAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,MAAM,IAA8B;AACpC;AACA,GAAG,MAAM,EAMN;AACH,CAAC;;;;;;;;;;;;;;AC3LY,4CAA4C,WAAW,EAAE,0BAA0B,+CAA+C,uCAAuC,0DAA0D,yCAAyC,YAAY,eAAe,KAAK,wBAAwB,mDAAmD,6BAA6B,iDAAiD,yDAAyD,0DAA0D,kEAAkE,0DAA0D,mBAAmB,sBAAsB,0BAA0B,kEAAkE,8BAA8B,mBAAmB,KAAK,8BAA8B,8GAA8G,oBAAoB;AAC5hC;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","file":"vendors~details-sidebar.no.react.js","sourcesContent":["\"use strict\";\n\n/**\r\n * filesize\r\n *\r\n * @copyright 2019 Jason Mulligan <jason.mulligan@avoidwork.com>\r\n * @license BSD-3-Clause\r\n * @version 4.2.1\r\n */\n(function (global) {\n  var b = /^(b|B)$/,\n      symbol = {\n    iec: {\n      bits: [\"b\", \"Kib\", \"Mib\", \"Gib\", \"Tib\", \"Pib\", \"Eib\", \"Zib\", \"Yib\"],\n      bytes: [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"]\n    },\n    jedec: {\n      bits: [\"b\", \"Kb\", \"Mb\", \"Gb\", \"Tb\", \"Pb\", \"Eb\", \"Zb\", \"Yb\"],\n      bytes: [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]\n    }\n  },\n      fullform = {\n    iec: [\"\", \"kibi\", \"mebi\", \"gibi\", \"tebi\", \"pebi\", \"exbi\", \"zebi\", \"yobi\"],\n    jedec: [\"\", \"kilo\", \"mega\", \"giga\", \"tera\", \"peta\", \"exa\", \"zetta\", \"yotta\"]\n  };\n  /**\r\n   * filesize\r\n   *\r\n   * @method filesize\r\n   * @param  {Mixed}   arg        String, Int or Float to transform\r\n   * @param  {Object}  descriptor [Optional] Flags\r\n   * @return {String}             Readable file size String\r\n   */\n\n  function filesize(arg) {\n    var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var result = [],\n        val = 0,\n        e = void 0,\n        base = void 0,\n        bits = void 0,\n        ceil = void 0,\n        full = void 0,\n        fullforms = void 0,\n        locale = void 0,\n        localeOptions = void 0,\n        neg = void 0,\n        num = void 0,\n        output = void 0,\n        round = void 0,\n        unix = void 0,\n        separator = void 0,\n        spacer = void 0,\n        standard = void 0,\n        symbols = void 0;\n\n    if (isNaN(arg)) {\n      throw new TypeError(\"Invalid number\");\n    }\n\n    bits = descriptor.bits === true;\n    unix = descriptor.unix === true;\n    base = descriptor.base || 2;\n    round = descriptor.round !== void 0 ? descriptor.round : unix ? 1 : 2;\n    locale = descriptor.locale !== void 0 ? descriptor.locale : \"\";\n    localeOptions = descriptor.localeOptions || {};\n    separator = descriptor.separator !== void 0 ? descriptor.separator : \"\";\n    spacer = descriptor.spacer !== void 0 ? descriptor.spacer : unix ? \"\" : \" \";\n    symbols = descriptor.symbols || {};\n    standard = base === 2 ? descriptor.standard || \"jedec\" : \"jedec\";\n    output = descriptor.output || \"string\";\n    full = descriptor.fullform === true;\n    fullforms = descriptor.fullforms instanceof Array ? descriptor.fullforms : [];\n    e = descriptor.exponent !== void 0 ? descriptor.exponent : -1;\n    num = Number(arg);\n    neg = num < 0;\n    ceil = base > 2 ? 1000 : 1024; // Flipping a negative number to determine the size\n\n    if (neg) {\n      num = -num;\n    } // Determining the exponent\n\n\n    if (e === -1 || isNaN(e)) {\n      e = Math.floor(Math.log(num) / Math.log(ceil));\n\n      if (e < 0) {\n        e = 0;\n      }\n    } // Exceeding supported length, time to reduce & multiply\n\n\n    if (e > 8) {\n      e = 8;\n    }\n\n    if (output === \"exponent\") {\n      return e;\n    } // Zero is now a special case because bytes divide by 1\n\n\n    if (num === 0) {\n      result[0] = 0;\n      result[1] = unix ? \"\" : symbol[standard][bits ? \"bits\" : \"bytes\"][e];\n    } else {\n      val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));\n\n      if (bits) {\n        val = val * 8;\n\n        if (val >= ceil && e < 8) {\n          val = val / ceil;\n          e++;\n        }\n      }\n\n      result[0] = Number(val.toFixed(e > 0 ? round : 0));\n\n      if (result[0] === ceil && e < 8 && descriptor.exponent === void 0) {\n        result[0] = 1;\n        e++;\n      }\n\n      result[1] = base === 10 && e === 1 ? bits ? \"kb\" : \"kB\" : symbol[standard][bits ? \"bits\" : \"bytes\"][e];\n\n      if (unix) {\n        result[1] = standard === \"jedec\" ? result[1].charAt(0) : e > 0 ? result[1].replace(/B$/, \"\") : result[1];\n\n        if (b.test(result[1])) {\n          result[0] = Math.floor(result[0]);\n          result[1] = \"\";\n        }\n      }\n    } // Decorating a 'diff'\n\n\n    if (neg) {\n      result[0] = -result[0];\n    } // Applying custom symbol\n\n\n    result[1] = symbols[result[1]] || result[1];\n\n    if (locale === true) {\n      result[0] = result[0].toLocaleString();\n    } else if (locale.length > 0) {\n      result[0] = result[0].toLocaleString(locale, localeOptions);\n    } else if (separator.length > 0) {\n      result[0] = result[0].toString().replace(\".\", separator);\n    } // Returning Array, Object, or String (default)\n\n\n    if (output === \"array\") {\n      return result;\n    }\n\n    if (full) {\n      result[1] = fullforms[e] ? fullforms[e] : fullform[standard][e] + (bits ? \"bit\" : \"byte\") + (result[0] === 1 ? \"\" : \"s\");\n    }\n\n    if (output === \"object\") {\n      return {\n        value: result[0],\n        symbol: result[1]\n      };\n    }\n\n    return result.join(spacer);\n  } // Partial application for functional programming\n\n\n  filesize.partial = function (opt) {\n    return function (arg) {\n      return filesize(arg, opt);\n    };\n  }; // CommonJS, AMD, script tag\n\n\n  if (typeof exports !== \"undefined\") {\n    module.exports = filesize;\n  } else if (typeof define === \"function\" && define.amd !== void 0) {\n    define(function () {\n      return filesize;\n    });\n  } else {\n    global.filesize = filesize;\n  }\n})(typeof window !== \"undefined\" ? window : global);\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports[\"default\"]=void 0;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\")}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor}function _typeof(obj){\"@babel/helpers - typeof\";if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj}}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj}}return _typeof(obj)}/**\n * TreeNode.js - build, construct, and deconstruct a tree\n *\n * @license\n * Copyright Â© 2019, 2021 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */function isNode(obj){return _typeof(obj)===\"object\"&&obj instanceof Node}/**\n * @class Node\n * @param {Object} an object to make into a tree node\n */var Node=/*#__PURE__*/function(){/**\n     * Create a new node instance.\n     */function Node(obj){var _this=this;_classCallCheck(this,Node);if(obj){// shallow copy all properties into this node\nObject.keys(obj).forEach(function(key){if(key!==\"children\"&&typeof obj[key]!==\"undefined\"){_this[key]=obj[key]}})}else{this.type=\"text\"}this.children=[]}/**\n     * Add a child node to the current context of the tree.\n     * @param {Node} child the child to add\n     */_createClass(Node,[{key:\"add\",value:function add(child){if(!isNode(child)){return}this.children.push(child)}},{key:\"addChildren\",value:function addChildren(array){var _this2=this;if(!Array.isArray(array)||!array.every(function(element){return element instanceof Node})){return}array.forEach(function(element){return _this2.add(element)})}/**\n     * Flatten the current node and all of its descendents into an\n     * array and return it. When a node has children, it is\n     * flattened into two nodes: a start node, followed by nodes for\n     * all its children, and an end node. The start and end nodes\n     * are marked by a \"use\" property set to \"start\" and \"end\".\n     *\n     * @returns {Array.<Node>} an array of Nodes flattened from\n     * the current node\n     */},{key:\"toArray\",value:function toArray(){if(this.children.length){var ret=[];var clone=new Node(this);clone.use=\"start\";ret.push(clone);for(var i=0;i<this.children.length;i++){ret=ret.concat(this.children[i].toArray())}clone=new Node(this);clone.use=\"end\";ret.push(clone);return ret}else if(this.type===\"text\"){this.use=undefined;return[this]}else{// self closing component\nvar clone=new Node(this);clone.use=\"startend\";return[clone]}}/**\n     * Recreate a full tree again from a flattened array of Node\n     * instances. If the instances are well-formed (that is,\n     * all start nodes are matched with end nodes with strict\n     * nesting), then the tree is valid. If the array is not\n     * well-formed, then the shape of the resulting tree will\n     * probably not be valid and the results of this static method\n     * are not defined.\n     *\n     * @static\n     * @param {Array.<Node>} array the array of Node instances\n     * to reconstruct into a tree\n     * @returns {Node} a node that is the root of a tree\n     * reconstructed from the array of Nodes\n     */}],[{key:\"fromArray\",value:function fromArray(array){if(!array||!Array.isArray(array)||!array.length){return undefined}if(!array.every(function(node){return _typeof(node)===\"object\"})){return undefined}var clone;if(array.length===1){if(isNode(array[0])){clone=new Node(array[0]);clone.use=undefined}return clone}var rootExtra,startIndex=0;if(array[0].use===\"start\"){rootExtra=array[0];startIndex=1}else{rootExtra={type:\"root\"};startIndex=0}// not a tree? Make a wrapper node!\nvar root=new Node(rootExtra);var stack=[];var current=root;root.use=undefined;stack.push(root);for(var i=startIndex;i<array.length;i++){if(isNode(array[i])){if(array[i].use===\"start\"){clone=new Node(array[i]);clone.use=undefined;stack.push(clone);current.add(clone);current=clone}else if(array[i].use===\"end\"){if(stack.length>1){stack.pop();current=stack[stack.length-1]}}else{current.add(array[i])}}}return root}}]);return Node}();exports[\"default\"]=Node;\n//# sourceMappingURL=TreeNode-es5.js.map\n","var root = require('./_root');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsFinite = root.isFinite;\n\n/**\n * Checks if `value` is a finite primitive number.\n *\n * **Note:** This method is based on\n * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n * @example\n *\n * _.isFinite(3);\n * // => true\n *\n * _.isFinite(Number.MIN_VALUE);\n * // => true\n *\n * _.isFinite(Infinity);\n * // => false\n *\n * _.isFinite('3');\n * // => false\n */\nfunction isFinite(value) {\n  return typeof value == 'number' && nativeIsFinite(value);\n}\n\nmodule.exports = isFinite;\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nmodule.exports = isNil;\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports[\"default\"]=void 0;var _ilibTreeNode=_interopRequireDefault(require(\"ilib-tree-node\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\")}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor}// take care of all Unicode whitespace as well as what JS thinks is whitespace\nvar whiteSpaceStart=/^[\\t-\\r \\xA0\\u1680\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060\\u3000\\uFEFF]+/;var whiteSpaceEnd=/[\\t-\\r \\xA0\\u1680\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060\\u3000\\uFEFF]+$/;var whiteSpace=/[\\t-\\r \\xA0\\u1680\\u2000-\\u200D\\u2028\\u2029\\u202F\\u205F\\u2060\\u3000\\uFEFF]+/g;// use [\\s\\S]*? instead of .* with the \"s\" flag because node 6 and earlier throw errors about the unknown \"s\" flag\nvar re=/(<(c\\d+)>[\\s\\S]*?<\\/\\2>)/g;var first=/^<c(\\d+)>/;var selfclosing=/(<([cp](\\d+))\\/>)/g;// \"c\" for component, \"p\" for parameter\n/**\n * MessageAccumulator.js - accumulate a translatable message as a string\n */var MessageAccumulator=/*#__PURE__*/function(){/**\n     * Create a new accumulator instance.\n     */function MessageAccumulator(){_classCallCheck(this,MessageAccumulator);this.root=new _ilibTreeNode[\"default\"]({type:\"root\",parent:null,index:-1});this.currentLevel=this.root;this.componentIndex=0;this.paramIndex=0;this.text=\"\";this.mapping={}}/**\n     * Factory method to create a new MessageAccumulator instance from\n     * the given string and a source message accumulator. This will\n     * parse the string and create the equivalent tree from it, and\n     * then attach the \"extra\" information from the source accumulator\n     * to the equivalent nodes in the new accumulator. This includes\n     * the source information for components and replacement parameters.\n     *\n     * @param {String} translated the translated string to parse\n     * @param {MessageAccumulator} source the source message\n     * for this translation\n     * @returns {MessageAccumulator} a new message accumulator\n     * instance equivalent to the given string\n     */_createClass(MessageAccumulator,[{key:\"_parse\",/**\n     * @private\n     */value:function _parse(string,mapping,parent){var match;re.lastIndex=0;var parts=string.split(re);for(var i=0;i<parts.length;i++){first.lastIndex=0;selfclosing.lastIndex=0;if((match=first.exec(parts[i]))!==null){var index=parseInt(match[1]);var len=match[0].length;// strip off the outer tags before processing the stuff in the middle\nvar substr=parts[i].substring(len,parts[i].length-len-1);var component=new _ilibTreeNode[\"default\"]({type:\"component\",parent:parent,index:index,extra:mapping&&mapping[\"c\".concat(index)]});this._parse(substr,mapping,component);parent.add(component);i++;// skip the number in the next iteration\n}else if(parts[i]&&parts[i].length){var subparts=parts[i].split(selfclosing);for(var j=0;j<subparts.length;j++){selfclosing.lastIndex=0;if((match=selfclosing.exec(subparts[j]))!==null){var _index=parseInt(match[3]);parent.add(new _ilibTreeNode[\"default\"]({type:match[2][0]===\"p\"?\"param\":\"component\",parent:parent,index:_index,extra:mapping&&mapping[match[2]]}));j+=2;// skip the other parts of the match in the next iteration\n}else if(subparts[j]&&subparts[j].length){// don't store empty strings\nparent.add(new _ilibTreeNode[\"default\"]({type:\"text\",value:subparts[j]}))}}}}}/**\n     * Add text to the current context of the string.\n     * @param {string} text the text to add\n     */},{key:\"addText\",value:function addText(text){if(typeof text===\"string\"){this.currentLevel.add(new _ilibTreeNode[\"default\"]({type:\"text\",value:text}))}this.text+=text}/**\n     * Add a replacement parameter to the string. This is a coding\n     * for a replacement parameter in the programming language\n     * or i18n library that does substitutions. By coding the replacement\n     * parameters instead of leaving them in as-is, the strings are\n     * normalized.<p>\n     *\n     * This has two advantages. First, translations for strings\n     * with the same text but different replacement parameter styles\n     * can be shared across i18n libraries. For\n     * example, some libraries use \"C\" style parameters like \"%1s\"\n     * and others use named parameters like \"{name}\". That means\n     * the translation of \"User %1s logged in.\" and of \"User {name}\n     * logged in.\" should have the exact same translation.<p>\n     *\n     * Second, the parameters can be numbered automatically so that\n     * the translator has the freedom to re-arrange the parameters\n     * in a string with multiple parameters as required by the\n     * grammar of the target language. For some parameter styles\n     * that use numbered parameters instead of named ones, the\n     * caller may need to amend original parameter to insert the\n     * number if the original code did not have it already. That\n     * is bad style anyways and you should strongly discourage your\n     * engineers from writing strings with multiple replacement\n     * parameters that are unnumbered.<p>\n     *\n     * Parameters appear in the composed string as XML tags that\n     * are distinct from the component tags. When creating a\n     * translated string, the parameters are substituted back\n     * into the string.\n     *\n     * @param {Object} extra extra information that the caller can\n     * use to identify the original replacement parameter\n     */},{key:\"addParam\",value:function addParam(extra){var index=this.paramIndex++;this.currentLevel.add(new _ilibTreeNode[\"default\"]({type:\"param\",index:index,extra:extra,closed:true}));var contents=\"p\".concat(index);this.text+=\"<\".concat(contents,\"/>\");this.mapping[contents]=extra}/**\n     * Create a new subcontext for a component such that all text\n     * added to the accumulator goes into the new context.<p>\n     *\n     * A component is represented in the composed string as an\n     * XML tag that is numbered according to the order of the\n     * components in the string. This class maintains a mapping\n     * between the component number and the given \"extra\"\n     * information so that this can be used to create a translated\n     * accumulator with the same extra info. (See the\n     * MessageAccumulator.create static function.)\n     *\n     * @param {Object} extra extra information that the caller would\n     * like to associate with the component. For example, this may\n     * be a node in an AST from parsing the original text.\n     * @param {boolean} keep true if this node should always be kept and\n     * not optimized out during the getMinimalString\n     */},{key:\"push\",value:function push(extra,keep){var newNode=new _ilibTreeNode[\"default\"]({type:\"component\",parent:this.currentLevel,index:this.componentIndex++,extra:extra,closed:false,keep:keep});this.currentLevel.add(newNode);this.currentLevel=newNode;this.mapping[\"c\".concat(newNode.index)]=extra}/**\n     * Pop the current context from the stack and return to the previous\n     * context. If the current context is already the root, then this\n     * represents an unbalanced string.\n     * @returns {Object|undefined} the extra information associated with the\n     * context that is being popped, or undefined if we are already at the\n     * root and there is nothing to pop\n     */},{key:\"pop\",value:function pop(){if(!this.currentLevel.parent){// oh oh, unbalanced?\nconsole.log(\"Unbalanced component error...\");// eslint-disable-line no-console\nreturn}var extra=this.currentLevel.extra;this.currentLevel.closed=true;this.currentLevel=this.currentLevel.parent;return extra}/**\n     * @private\n     */},{key:\"_getString\",value:function _getString(rootnode){if(rootnode.children.length===0){return rootnode.value||\"\"}return rootnode.children.map(function(child){return child.toArray().map(function(node){if(node.type===\"component\"){if(node.index>-1){if(node.use===\"start\"){return\"<c\".concat(node.index,\">\")}else if(node.use===\"end\"){return\"</c\".concat(node.index,\">\")}else{// self-closing\nreturn\"<c\".concat(node.index,\"/>\")}}}else if(node.type===\"param\"){// self-closing\nreturn\"<p\".concat(node.index,\"/>\")}else{return node.value}}).join(\"\")}).join(\"\")}/**\n     * @private\n     */},{key:\"_isEmpty\",value:function _isEmpty(node){var _this=this;whiteSpace.lastIndex=0;if(node.type===\"param\")return false;if(node.type===\"text\"&&node.value.replace(whiteSpace,\"\")!==\"\")return false;if(node.type===\"component\"){if(node.keep)return false;if(node.children&&node.children.length){return node.children.every(function(child){return _this._isEmpty(child)})}}return true}/**\n     * @private\n     */},{key:\"_renumber\",value:function _renumber(node){var _this2=this;if(node.type===\"component\"){node.index=this.componentIndex++;this.mapping[\"c\".concat(node.index)]=node.extra}else if(node.type===\"param\"){this.mapping[\"p\".concat(node.index)]=node.extra}if(node.children){node.children.forEach(function(child){_this2._renumber(child)})}}/**\n     * @private\n     */},{key:\"_minimize\",value:function _minimize(){if(this.minimized)return;var value,changed=true;if(!this.prefixes)this.prefixes=[];if(!this.suffixes)this.suffixes=[];// keep stripping off parts until we haven't changed anything, or we have stripped off everything\nwhile(changed&&this.root.children&&this.root.children.length){changed=false;var subroot=this.root;// check for \"outer\" components -- components that surround localizable text without adding anything to it\nwhile(subroot.children&&subroot.children.length===1&&subroot.children[0].type!==\"text\"&&!subroot.children[0].keep){subroot=subroot.children[0];value=new _ilibTreeNode[\"default\"](subroot);value.use=\"start\";this.prefixes.push(value);value=new _ilibTreeNode[\"default\"](subroot);value.use=\"end\";this.suffixes=[value].concat(this.suffixes);changed=true}var children=subroot.children;// find empty components at the start\nvar i=0;while(i<children.length&&children[i]&&this._isEmpty(children[i])){this.prefixes=this.prefixes.concat(children[i].toArray());i++;changed=true}children=i>0?children.slice(i):children;// then find empty components at the end\nvar i=children.length-1;while(i>0&&children[i]&&this._isEmpty(children[i])){this.suffixes=children[i].toArray().concat(this.suffixes);i--;changed=true}// now strip off the leading and trailing whitespace\nif(children.length&&children[0].type===\"text\"){whiteSpaceStart.lastIndex=0;var match=whiteSpaceStart.exec(children[0].value);if(match){children[0].value=children[0].value.substring(match[0].length);this.prefixes.push(new _ilibTreeNode[\"default\"]({type:\"text\",value:match[0]}));changed=true}}var last=children.length-1;if(children.length&&children[last].type===\"text\"){whiteSpaceEnd.lastIndex=0;var match=whiteSpaceEnd.exec(children[last].value);if(match){children[last].value=children[last].value.substring(0,children[last].value.length-match[0].length);this.suffixes=[new _ilibTreeNode[\"default\"]({type:\"text\",value:match[0]})].concat(this.suffixes);changed=true}}this.root.children=i<children.length-1?children.slice(0,i+1):children;// then do it all again until nothing changes!\n}// now walk the tree again and renumber any components so that we don't start at some number greater\n// than zero\nthis.componentIndex=0;this.mapping={};this._renumber(this.root);this.minimized=true}/**\n     * Return the message accumulated so far, including any components\n     * as a string that contains \"c\" + a number to represent those\n     * components.\n     *\n     * @return {string} the accumulated string so far\n     */},{key:\"getString\",value:function getString(){return this._getString(this.root)}/**\n     * Return all of the irrelevant parts of the string at the beginning\n     * of the message.<p>\n     *\n     * For a minimal string, all of the components that are irrelevant\n     * for translation are removed. This method returns all of the irrelevant\n     * components and text units that appear at the beginning of the string.\n     *\n     * @returns {Array.<Object>} an array of \"extra\" and text units that\n     * are irrelevant\n     */},{key:\"getPrefix\",value:function getPrefix(){this._minimize();return this.prefixes||[]}/**\n     * Return the message accumulated so far as a string, including\n     * any components, and leaving out any contexts that are irrelevant\n     * for translation purposes. This method is similar to getString()\n     * with the irrelevant parts removed. This includes:\n     *\n     * <ul>\n     * <li>Any components that surround the entire message\n     * <li>Any components that are at the beginning or end of the message\n     * and which do not have any translatable text in them.\n     * <li>Any text at the beginning or end of the string that only\n     * contains whitespace.\n     * </ul>\n     *\n     * A minimal string must either start with non-whitespace text or end with\n     * non-whitespace text or both.<p>\n     *\n     * After all the irrelevant parts are removed, the remaining components\n     * are renumbered so that the first one to appear starts at zero, the\n     * second one is one, etc.\n     *\n     * @return {string} the accumuilated string so far with all irrelevant\n     * components removed.\n     */},{key:\"getMinimalString\",value:function getMinimalString(){this._minimize();return this._getString(this.root)}/**\n     * Return all of the irrelevant parts of the string at the end\n     * of the message.<p>\n     *\n     * For a minimal string, all of the components that are irrelevant\n     * for translation are removed. This method returns all of the irrelevant\n     * components and text units that appear at the end of the string.\n     *\n     * @returns {Array.<Object>} an array of \"extra\" and text units that\n     * are irrelevant\n     */},{key:\"getSuffix\",value:function getSuffix(){this._minimize();return this.suffixes||[]}/**\n     * Return the number of characters of non-whitespace text that\n     * have been accumulated so far in this accumulator. Components\n     * are left out.\n     * @return {number} the length of the non-whitespace text accumulated so far\n     */},{key:\"getTextLength\",value:function getTextLength(){whiteSpace.lastIndex=0;return this.text.replace(whiteSpace,\"\").trim().length}/**\n     * @private\n     * Return the depth of the stack from the given node.\n     */},{key:\"countCurrentLevel\",value:function countCurrentLevel(node){return node.parent?this.countCurrentLevel(node.parent)+1:0}/**\n     * Return the current depth of the context stack. If the accumulator is\n     * currently at the root, it will return 0.\n     * @returns {number} the current depth of the context stack, or 0 if there\n     * is nothing on the stack yet\n     */},{key:\"getCurrentLevel\",value:function getCurrentLevel(){return this.countCurrentLevel(this.currentLevel)}/**\n     * Return true if the current context is the root of the message.\n     * @return {boolean} true if the current context is the root\n     */},{key:\"isRoot\",value:function isRoot(){return this.componentIndex===0}/**\n     * Return the mapping between components and the \"extra\"\n     * information used when creating those components.\n     *\n     * @param {number} componentNumber the number of the\n     * component for which the \"extra\" information is\n     * being sought\n     * @returns {Object} the \"extra\" information that was\n     * given when the component was created\n     */},{key:\"getExtra\",value:function getExtra(componentNumber){return this.mapping[\"c\".concat(componentNumber)]}/**\n     * Return the mapping between a replacement parameter\n     * and the \"extra\" information used when creating those\n     * components.\n     *\n     * @param {number} paramNumber the number of the\n     * parameter for which the \"extra\" information is\n     * being sought\n     * @returns {Object} the \"extra\" information that was\n     * given when the parameter was created\n     */},{key:\"getParam\",value:function getParam(paramNumber){return this.mapping[\"p\".concat(paramNumber)]}/**\n     * Return the mappings between component names and\n     * their \"extra\" information they represent.\n     * @returns {Object} the mapping between the\n     * component names and their \"extra\" information.\n     */},{key:\"getMapping\",value:function getMapping(){return this.mapping}}],[{key:\"create\",value:function create(str,source){var ma=new MessageAccumulator;if(str){ma._parse(str,source&&source.getMapping()||{},ma.root)}return ma}}]);return MessageAccumulator}();exports[\"default\"]=MessageAccumulator;\n//# sourceMappingURL=message-accumulator-es5.js.map\n","'use strict';\n\nfunction processString(options) {\n    var key = 0;\n\n    function processInputWithRegex(option, input) {\n        if (!option.fn || typeof option.fn !== 'function') return input;\n\n        if (!option.regex || !(option.regex instanceof RegExp)) return input;\n\n        if (typeof input === 'string') {\n            var regex = option.regex;\n            var result = null;\n            var output = [];\n\n            while ((result = regex.exec(input)) !== null) {\n                var index = result.index;\n                var match = result[0];\n\n                output.push(input.substring(0, index));\n                output.push(option.fn(++key, result));\n\n                input = input.substring(index + match.length, input.length + 1);\n                regex.lastIndex = 0;\n            }\n\n            output.push(input);\n            return output;\n        } else if (Array.isArray(input)) {\n            return input.map(function (chunk) {\n                return processInputWithRegex(option, chunk);\n            });\n        } else return input;\n    }\n\n    return function (input) {\n        if (!options || !Array.isArray(options) || !options.length) return input;\n\n        options.forEach(function (option) {\n            return input = processInputWithRegex(option, input);\n        });\n\n        return input;\n    };\n}\n\nmodule.exports = processString;\n\n","module.exports = function(el, options) {\n  options = options || {};\n\n  var elementDocument = el.ownerDocument || el;\n  var basicTabbables = [];\n  var orderedTabbables = [];\n\n  // A node is \"available\" if\n  // - it's computed style\n  var isUnavailable = createIsUnavailable(elementDocument);\n\n  var candidateSelectors = [\n    'input',\n    'select',\n    'a[href]',\n    'textarea',\n    'button',\n    '[tabindex]',\n  ];\n\n  var candidates = el.querySelectorAll(candidateSelectors.join(','));\n\n  if (options.includeContainer) {\n    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\n    if (\n      candidateSelectors.some(function(candidateSelector) {\n        return matches.call(el, candidateSelector);\n      })\n    ) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var candidate, candidateIndexAttr, candidateIndex;\n  for (var i = 0, l = candidates.length; i < l; i++) {\n    candidate = candidates[i];\n    candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10)\n    candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;\n\n    if (\n      candidateIndex < 0\n      || (candidate.tagName === 'INPUT' && candidate.type === 'hidden')\n      || candidate.disabled\n      || isUnavailable(candidate, elementDocument)\n    ) {\n      continue;\n    }\n\n    if (candidateIndex === 0) {\n      basicTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        index: i,\n        tabIndex: candidateIndex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(function(a, b) {\n      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;\n    })\n    .map(function(a) {\n      return a.node\n    });\n\n  Array.prototype.push.apply(tabbableNodes, basicTabbables);\n\n  return tabbableNodes;\n}\n\nfunction createIsUnavailable(elementDocument) {\n  // Node cache must be refreshed on every check, in case\n  // the content of the element has changed\n  var isOffCache = [];\n\n  // \"off\" means `display: none;`, as opposed to \"hidden\",\n  // which means `visibility: hidden;`. getComputedStyle\n  // accurately reflects visiblity in context but not\n  // \"off\" state, so we need to recursively check parents.\n\n  function isOff(node, nodeComputedStyle) {\n    if (node === elementDocument.documentElement) return false;\n\n    // Find the cached node (Array.prototype.find not available in IE9)\n    for (var i = 0, length = isOffCache.length; i < length; i++) {\n      if (isOffCache[i][0] === node) return isOffCache[i][1];\n    }\n\n    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);\n\n    var result = false;\n\n    if (nodeComputedStyle.display === 'none') {\n      result = true;\n    } else if (node.parentNode) {\n      result = isOff(node.parentNode);\n    }\n\n    isOffCache.push([node, result]);\n\n    return result;\n  }\n\n  return function isUnavailable(node) {\n    if (node === elementDocument.documentElement) return false;\n\n    var computedStyle = elementDocument.defaultView.getComputedStyle(node);\n\n    if (isOff(node, computedStyle)) return true;\n\n    return computedStyle.visibility === 'hidden';\n  }\n}\n"],"sourceRoot":""}